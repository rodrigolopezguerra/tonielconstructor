<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Lego Builder 5.7 - Sumo Controls</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f0f0f0; font-family: 'Segoe UI', sans-serif; touch-action: none; user-select: none; -webkit-user-select: none; }
        
        #error-console { display: none; position: absolute; top: 0; left: 0; width: 100%; background: rgba(255,0,0,0.9); color: white; padding: 20px; z-index: 9999; font-family: monospace; font-size: 14px; white-space: pre-wrap; }

        /* UI Elements */
        #builder-ui { transition: opacity 0.3s; }
        #builder-ui.hidden { opacity: 0; pointer-events: none; }
        
        #ui-bottom-bar { position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); display: flex; flex-direction: column; align-items: center; gap: 10px; z-index: 10; width: 95%; max-width: 600px; pointer-events: none; }
        .ui-panel { background: rgba(255, 255, 255, 0.95); padding: 10px; border-radius: 15px; box-shadow: 0 4px 10px rgba(0,0,0,0.2); pointer-events: auto; display: flex; gap: 8px; overflow-x: auto; max-width: 100%; scrollbar-width: none; }
        .ui-panel::-webkit-scrollbar { display: none; }

        .color-btn { width: 40px; height: 40px; min-width: 40px; border-radius: 50%; border: 3px solid white; cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.2); transition: transform 0.1s; }
        .color-btn.selected { border: 3px solid #333; transform: scale(1.15); }

        .type-btn { padding: 8px 12px; border: 2px solid #ddd; background: white; border-radius: 8px; cursor: pointer; font-weight: bold; font-size: 14px; white-space: nowrap; transition: all 0.2s; }
        .type-btn.active { background: #2196F3; color: white; border-color: #1976D2; }

        #tools { position: absolute; top: 20px; right: 20px; display: flex; flexDirection: column; gap: 10px; z-index: 20;}
        .tool-btn { width: 50px; height: 50px; background: white; border: none; border-radius: 12px; font-size: 22px; cursor: pointer; box-shadow: 0 4px 6px rgba(0,0,0,0.1); transition: all 0.2s; }
        .tool-btn:active { transform: scale(0.95); }
        
        .modal { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border-radius: 15px; box-shadow: 0 10px 25px rgba(0,0,0,0.3); z-index: 30; width: 80%; max-height: 70%; overflow-y: auto; text-align: center; }
        #overlay-bg { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 25; }
        .saved-item { display: flex; justify-content: space-between; align-items: center; background: #f5f5f5; padding: 10px; margin-bottom: 8px; border-radius: 8px; font-size: 14px;}

        #player-controls { display: none; position: absolute; bottom: 30px; left: 20px; z-index: 15; touch-action: none; }
        #player-controls.visible { display: grid; grid-template-columns: 60px 60px 60px; grid-template-rows: 60px 60px; gap: 5px; }
        /* √çconos actualizados para reflejar movimiento Tanque (Giro vs Avance) */
        .dpad-btn { width: 60px; height: 60px; background: rgba(255,255,255,0.5); border: 2px solid #fff; border-radius: 15px; font-size: 30px; display: flex; justify-content: center; align-items: center; cursor: pointer; }
        #dpad-up { grid-column: 2; grid-row: 1; } /* Avanzar */
        #dpad-left { grid-column: 1; grid-row: 2; } /* Girar Izq */
        #dpad-down { grid-column: 2; grid-row: 2; } /* Retroceder */
        #dpad-right { grid-column: 3; grid-row: 2; } /* Girar Der */
        #btn-jump { display: none; position: absolute; bottom: 40px; right: 30px; width: 80px; height: 80px; background: rgba(255,255,255,0.5); border-radius: 50%; border: 3px solid white; font-weight: bold; z-index: 15; }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="error-console"></div>
    <div id="overlay-bg"></div>

    <div id="load-modal" class="modal">
        <h3>Partidas Guardadas</h3>
        <div id="saved-list"></div>
        <button style="margin-top:15px; padding:10px;" onclick="closeAllModals()">Cerrar</button>
    </div>

    <div id="tools">
        <button id="btn-toggle-play" class="tool-btn">üéÆ</button>
        <div id="builder-tools">
            <button id="btn-save" class="tool-btn">üíæ</button>
            <button id="btn-load" class="tool-btn">üìÇ</button>
            <button id="btn-mode" class="tool-btn">üóëÔ∏è</button>
            <button id="btn-clear" class="tool-btn">üîÑ</button>
        </div>
    </div>

    <div id="builder-ui">
        <div id="ui-bottom-bar">
            <div class="ui-panel" id="type-selector">
                <button class="type-btn active" onclick="setBuildType('cube')">‚ñ† Cubo</button>
                <button class="type-btn" onclick="setBuildType('ramp')">‚ó¢ Rampa</button>
                <button class="type-btn" onclick="setBuildType('door')">üö™ Puerta</button>
                <button class="type-btn" onclick="setBuildType('move1')">‚ÜîÔ∏è 1</button>
                <button class="type-btn" onclick="setBuildType('move2')">‚ÜîÔ∏è 2</button>
                <button class="type-btn" onclick="setBuildType('move3')">‚ÜîÔ∏è 3</button>
            </div>
            <div class="ui-panel">
                <div class="color-btn selected" style="background-color: #d32f2f;" onclick="setColor(this, 0xd32f2f)"></div>
                <div class="color-btn" style="background-color: #1976d2;" onclick="setColor(this, 0x1976d2)"></div>
                <div class="color-btn" style="background-color: #fbc02d;" onclick="setColor(this, 0xfbc02d)"></div>
                <div class="color-btn" style="background-color: #388e3c;" onclick="setColor(this, 0x388e3c)"></div>
                <div class="color-btn" style="background-color: #fff;" onclick="setColor(this, 0xffffff)"></div>
                <div class="color-btn" style="background-color: #212121;" onclick="setColor(this, 0x212121)"></div>
            </div>
        </div>
    </div>

    <div id="player-controls">
        <div class="dpad-btn" id="dpad-up">‚¨ÜÔ∏è</div>
        <div class="dpad-btn" id="dpad-left">‚¨ÖÔ∏è</div> <div class="dpad-btn" id="dpad-down">‚¨áÔ∏è</div>
        <div class="dpad-btn" id="dpad-right">‚û°Ô∏è</div> </div>
    <button id="btn-jump">SALTAR</button>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        window.onerror = function(msg, url, lineNo, columnNo, error) {
            const consoleDiv = document.getElementById('error-console');
            consoleDiv.style.display = 'block';
            consoleDiv.innerText += `Error: ${msg}\nLine: ${lineNo}\n\n`;
            return false;
        };

        // CONFIG (A√±adido rotSpeed del c√≥digo Sumo)
        const CONF = { 
            gridSize: 2000, 
            cellSize: 50, 
            gravity: 2000, 
            speed: 500, 
            rotSpeed: 3.0, // Velocidad de giro
            jump: 800,
            camDist: 250, // Distancia c√°mara
            camHeight: 150 // Altura c√°mara
        };

        let camera, scene, renderer, controls;
        let plane, gridHelper;
        let raycaster = new THREE.Raycaster();
        let pointer = new THREE.Vector2();
        let clock = new THREE.Clock();

        let objects = []; 
        let movingObjects = [];
        let doors = [];
        
        let buildType = 'cube';
        let currentColor = 0xd32f2f;
        let isShiftDown = false;
        
        let rollOverMesh, rampGuideMesh;
        let cubeGeo, rampGeo;
        
        let isPlayingMode = false;
        let player;
        let playerVelocity = new THREE.Vector3();
        let moveInput = { up: false, down: false, left: false, right: false, jump: false };
        let cooldown = 0;
        
        const doorColors = [0x00ff00, 0xff00ff, 0x00ffff, 0xffaa00, 0xff0000, 0x0000ff, 0xffff00, 0xffffff, 0x8800ff, 0x00ff88];

        function createPlayer() {
            player = new THREE.Group();
            const body = new THREE.Mesh(new THREE.CapsuleGeometry(20, 50, 4, 8), new THREE.MeshLambertMaterial({ color: 0x00ffff }));
            body.position.y = 45;
            player.add(body);
            
            // Ojos en Z positivo (adelante seg√∫n l√≥gica Sumo)
            const e1 = new THREE.Mesh(new THREE.BoxGeometry(10,5,5), new THREE.MeshBasicMaterial({ color: 0 }));
            const e2 = e1.clone();
            e1.position.set(-8, 65, 15); 
            e2.position.set(8, 65, 15);
            player.add(e1); player.add(e2);
            
            player.position.set(0, 200, 0);
            player.visible = false;
            scene.add(player);
        }

        function createObject(pos, type, meta = null) {
            let mesh;
            let colorToUse = currentColor;
            if(meta && meta.col) colorToUse = meta.col;

            const mat = new THREE.MeshLambertMaterial({ color: colorToUse });
            
            if(type === 'cube') {
                mesh = new THREE.Mesh(cubeGeo, mat);
                mesh.position.copy(pos);
            }
            else if(type.startsWith('move')) {
                mesh = new THREE.Mesh(cubeGeo, mat);
                mesh.position.copy(pos);
                mesh.add(new THREE.LineSegments(new THREE.EdgesGeometry(cubeGeo), new THREE.LineBasicMaterial({color:0})));
                let range = 1;
                if(type === 'move2') range = 2;
                if(type === 'move3') range = 3;
                mesh.userData = { type: type, origin: pos.clone(), range: range };
                movingObjects.push(mesh);
            }
            else if(type === 'ramp') {
                mesh = new THREE.Mesh(rampGeo, mat);
                mesh.position.copy(pos).add(new THREE.Vector3(25, 50, 25));
                mesh.rotation.y = -Math.PI / 2;
                mesh.userData = { type: 'ramp' };
            }
            else if(type === 'door') {
                const grp = new THREE.Group();
                const frame = new THREE.Mesh(new THREE.BoxGeometry(40,80,10), new THREE.MeshLambertMaterial({color:0x333333}));
                frame.position.y=15;
                
                let pid, pcol;
                
                if(meta && meta.pid) { 
                    pid = meta.pid; 
                    pcol = meta.pcol; 
                } else {
                    const orphan = doors.find(d => {
                        const partner = doors.find(p => p !== d && p.userData.pid === d.userData.pid);
                        return !partner;
                    });
                    if(orphan) { 
                        pid = orphan.userData.pid; 
                        pcol = orphan.userData.pcol; 
                    } else { 
                        pid = Date.now(); 
                        const uniquePids = new Set(doors.map(d => d.userData.pid));
                        const colorIndex = uniquePids.size; 
                        pcol = doorColors[colorIndex % doorColors.length]; 
                    }
                }
                
                const inner = new THREE.Mesh(new THREE.BoxGeometry(30,70,5), new THREE.MeshBasicMaterial({color: pcol}));
                inner.position.set(0,15,2);
                grp.add(frame); grp.add(inner);
                grp.position.copy(pos).add(new THREE.Vector3(0,15,0));
                mesh = grp;
                mesh.userData = { type:'door', pid: pid, pcol: pcol };
                doors.push(mesh);
            }

            if(mesh) {
                if(!mesh.userData.type) mesh.userData.type = type;
                scene.add(mesh);
                objects.push(mesh);
            }
        }

        function update(delta) {
            cooldown -= delta;
            const time = clock.getElapsedTime();

            // 1. Movimiento Bloques
            movingObjects.forEach(obj => {
                const oldPos = obj.position.clone();
                const factor = (Math.sin(time * 2) + 1) / 2; 
                const distance = obj.userData.range * 50;    
                const offset = factor * distance;
                obj.position.x = obj.userData.origin.x + offset;
                obj.userData.delta = obj.position.clone().sub(oldPos);
            });

            if(!isPlayingMode) return;

            // 2. L√≥gica de Puertas
            if(cooldown <= 0) {
                for(let d of doors) {
                    const distH = Math.sqrt(Math.pow(player.position.x - d.position.x, 2) + Math.pow(player.position.z - d.position.z, 2));
                    const distV = Math.abs(player.position.y - d.position.y);
                    if(distH < 50 && distV < 60) {
                        const partner = doors.find(x => x.userData.pid === d.userData.pid && x !== d);
                        if(partner) {
                            player.position.copy(partner.position);
                            player.position.z += 10; cooldown = 2.0;
                            break;
                        }
                    }
                }
            }

            // 3. F√çSICAS ESTILO SUMO (Modificadas para el jugador)
            playerVelocity.y -= CONF.gravity * delta;

            // A) Rotaci√≥n (Input Izq/Der gira al personaje)
            if(moveInput.left) player.rotation.y += CONF.rotSpeed * delta;
            if(moveInput.right) player.rotation.y -= CONF.rotSpeed * delta;

            // B) Calcular Vector Adelante basado en rotaci√≥n actual
            // En el c√≥digo de Sumo se usa (0,0,1) rotado.
            const fwd = new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(0,1,0), player.rotation.y);

            // C) Velocidad de Avance/Retroceso
            let currentSpeed = 0;
            if(moveInput.up) currentSpeed = CONF.speed;
            if(moveInput.down) currentSpeed = -CONF.speed;

            // Aplicamos la velocidad al vector de movimiento horizontal
            playerVelocity.x = fwd.x * currentSpeed;
            playerVelocity.z = fwd.z * currentSpeed;

            // Gravedad y Suelo (Mantenemos la l√≥gica de Lego Builder para colisiones)
            let onGround = false;
            const rayDown = new THREE.Raycaster(new THREE.Vector3(player.position.x, player.position.y + 20, player.position.z), new THREE.Vector3(0,-1,0), 0, 25);
            const hits = rayDown.intersectObjects(objects, false);
            if(hits.length > 0 && playerVelocity.y <= 0) {
                player.position.y = hits[0].point.y;
                playerVelocity.y = 0;
                onGround = true;
                let hObj = hits[0].object;
                while(hObj.parent && hObj.parent !== scene) hObj = hObj.parent;
                if(hObj.userData.delta) player.position.add(hObj.userData.delta);
            }

            if(moveInput.jump && onGround) { playerVelocity.y = CONF.jump; moveInput.jump = false; }

            // Paredes (Detecci√≥n Frontal simplificada)
            if(currentSpeed !== 0) {
                const moveDir = fwd.clone().normalize();
                if (currentSpeed < 0) moveDir.negate(); // Si va marcha atr√°s

                const rayFwd = new THREE.Raycaster(new THREE.Vector3(player.position.x, player.position.y+20, player.position.z), moveDir, 0, 25);
                const wHits = rayFwd.intersectObjects(objects, false);
                if(wHits.length > 0) {
                     let hObj = wHits[0].object;
                     while(hObj.parent && hObj.parent !== scene) hObj = hObj.parent;
                     // Si no es rampa, paramos
                     if(hObj.userData.type !== 'ramp') { 
                        playerVelocity.x = 0; 
                        playerVelocity.z = 0; 
                     }
                }
            }

            // Aplicar movimiento
            player.position.addScaledVector(playerVelocity, delta);
            
            // Reset ca√≠da
            if(player.position.y < -500) { player.position.set(0,200,0); playerVelocity.set(0,0,0); }
            
            // 4. C√ÅMARA (Estilo Sumo: Sigue r√≠gidamente la rotaci√≥n del jugador)
            // Calculamos el offset relativo (atr√°s y arriba)
            const relativeOffset = new THREE.Vector3(0, CONF.camHeight, -CONF.camDist);
            // Lo rotamos seg√∫n a donde mira el jugador
            relativeOffset.applyAxisAngle(new THREE.Vector3(0,1,0), player.rotation.y);
            
            // Destino de la c√°mara
            const camDest = player.position.clone().add(relativeOffset);
            
            // Interpolamos posici√≥n (Lerp) para suavidad, como en el Sumo
            camera.position.lerp(camDest, 0.1);
            // Miramos un poco por encima del jugador
            camera.lookAt(player.position.clone().add(new THREE.Vector3(0, 20, 0)));
        }

        // --- INTERACCI√ìN ---

        function onPointerMove(e) {
            if(isPlayingMode) return;
            pointer.set((e.clientX/window.innerWidth)*2-1, -(e.clientY/window.innerHeight)*2+1);
            raycaster.setFromCamera(pointer, camera);
            const hits = raycaster.intersectObjects(objects, false);
            if(hits.length > 0 && !isShiftDown) {
                const pos = hits[0].point.add(hits[0].face.normal).divideScalar(50).floor().multiplyScalar(50).addScalar(25);
                if(buildType === 'ramp') {
                    rampGuideMesh.position.copy(pos).add(new THREE.Vector3(25, 50, 25));
                    rampGuideMesh.visible = true; rollOverMesh.visible = false;
                } else {
                    rollOverMesh.position.copy(pos);
                    rollOverMesh.visible = true; rampGuideMesh.visible = false;
                }
            }
        }

        function onPointerDown(e) {
            if(isPlayingMode || e.target.closest('button') || e.target.closest('.ui-panel') || e.target.closest('.modal')) return;
            pointer.set((e.clientX/window.innerWidth)*2-1, -(e.clientY/window.innerHeight)*2+1);
            raycaster.setFromCamera(pointer, camera);
            const hits = raycaster.intersectObjects(objects, false);
            if(hits.length > 0) {
                const obj = hits[0].object;
                let targetObj = obj;
                while(targetObj.parent && targetObj.parent !== scene) { targetObj = targetObj.parent; }
                if(isShiftDown) {
                    if(targetObj !== plane) {
                        scene.remove(targetObj);
                        const idx = objects.indexOf(targetObj); if(idx>-1) objects.splice(idx,1);
                        const midx = movingObjects.indexOf(targetObj); if(midx>-1) movingObjects.splice(midx,1);
                        const didx = doors.indexOf(targetObj); if(didx>-1) doors.splice(didx,1);
                    }
                } else {
                    const pos = hits[0].point.add(hits[0].face.normal).divideScalar(50).floor().multiplyScalar(50).addScalar(25);
                    createObject(pos, buildType);
                }
            }
        }

        function onKeyDown(e) {
            if(!isPlayingMode) { if(e.key==='Shift') isShiftDown=true; return; }
            if(e.key==='w'||e.key==='ArrowUp') moveInput.up=true;
            if(e.key==='s'||e.key==='ArrowDown') moveInput.down=true;
            if(e.key==='a'||e.key==='ArrowLeft') moveInput.left=true;
            if(e.key==='d'||e.key==='ArrowRight') moveInput.right=true;
            if(e.code==='Space') moveInput.jump=true;
        }
        function onKeyUp(e) {
            if(!isPlayingMode) { if(e.key==='Shift') isShiftDown=false; return; }
            if(e.key==='w'||e.key==='ArrowUp') moveInput.up=false;
            if(e.key==='s'||e.key==='ArrowDown') moveInput.down=false;
            if(e.key==='a'||e.key==='ArrowLeft') moveInput.left=false;
            if(e.key==='d'||e.key==='ArrowRight') moveInput.right=false;
            if(e.code==='Space') moveInput.jump=false;
        }

        function setupUI() {
            window.setBuildType = (t) => { 
                buildType = t; 
                document.querySelectorAll('.type-btn').forEach(b => b.classList.remove('active'));
                const btns = document.querySelectorAll('.type-btn');
                btns.forEach(btn => { if(btn.onclick.toString().includes(t)) btn.classList.add('active'); });
                if(t==='ramp') { rollOverMesh.visible=false; rampGuideMesh.visible=true; }
                else { rollOverMesh.visible=true; rampGuideMesh.visible=false; }
            };
            window.setColor = (el, c) => { 
                currentColor = c; 
                rollOverMesh.material.color.setHex(c);
                document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('selected'));
                el.classList.add('selected');
            };
            document.getElementById('btn-toggle-play').onclick = toggleMode;
            document.getElementById('btn-mode').onclick = (e) => { isShiftDown = !isShiftDown; e.target.style.borderColor = isShiftDown ? 'red' : 'none'; rollOverMesh.visible = !isShiftDown; };
            document.getElementById('btn-clear').onclick = () => {
                if(confirm('¬øBorrar todo?')) {
                    for(let i=objects.length-1; i>0; i--) scene.remove(objects[i]);
                    objects=[plane]; movingObjects=[]; doors=[];
                }
            };
            document.getElementById('btn-save').onclick = () => {
                if(objects.length<2) return alert("Construye algo primero");
                const name = prompt('Nombre del nivel?'); if(!name) return;
                const data = [];
                for(let i=1; i<objects.length; i++) {
                    const o = objects[i];
                    let c = currentColor;
                    if(o.material && o.material.color) c = o.material.color.getHex();
                    else if(o.children && o.children[0].material) c = o.children[0].material.color.getHex(); 
                    data.push({ t: o.userData.type, x:o.position.x, y:o.position.y, z:o.position.z, col:c, meta: o.userData });
                }
                localStorage.setItem('lego_v5_'+name, JSON.stringify(data));
                alert('Guardado: ' + name);
            };
            document.getElementById('btn-load').onclick = () => {
                const list = document.getElementById('saved-list'); list.innerHTML = '';
                let count = 0;
                for(let i=0; i<localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if(key.startsWith('lego_v5_')) {
                        const name = key.replace('lego_v5_','');
                        list.innerHTML += `<div class="saved-item"><span>${name}</span> <button onclick="loadLvl('${key}')">Cargar</button></div>`;
                        count++;
                    }
                }
                if(count===0) list.innerHTML = "<p>No hay partidas.</p>";
                document.getElementById('load-modal').style.display='block';
                document.getElementById('overlay-bg').style.display='block';
            };
            window.loadLvl = (key) => {
                const data = JSON.parse(localStorage.getItem(key));
                for(let i=objects.length-1; i>0; i--) scene.remove(objects[i]);
                objects=[plane]; movingObjects=[]; doors=[];
                data.forEach(d => createObject(new THREE.Vector3(d.x,d.y,d.z), d.t, d.meta));
                closeAllModals();
            };
            window.closeAllModals = () => { document.querySelectorAll('.modal').forEach(m=>m.style.display='none'); document.getElementById('overlay-bg').style.display='none'; };
        }

        function toggleMode() {
            isPlayingMode = !isPlayingMode;
            const btn = document.getElementById('btn-toggle-play');
            const bUI = document.getElementById('builder-ui');
            const pUI = document.getElementById('player-controls');
            const jBtn = document.getElementById('btn-jump');
            
            if(isPlayingMode) {
                // MODO JUEGO: DESACTIVAMOS ORBITCONTROLS
                btn.innerText = 'üî®'; 
                bUI.style.opacity = 0; bUI.style.pointerEvents = 'none'; 
                pUI.style.display = 'grid'; jBtn.style.display = 'block'; 
                document.getElementById('builder-tools').style.display = 'none';
                
                player.visible = true; 
                controls.enabled = false; // Importante: Desactivar para que no pelee con nuestra l√≥gica de c√°mara

                rollOverMesh.visible = false; rampGuideMesh.visible = false;
                if(player.position.y<0) player.position.set(0,200,0);
            } else {
                // MODO CONSTRUIR: ACTIVAMOS ORBITCONTROLS
                btn.innerText = 'üéÆ'; 
                bUI.style.opacity = 1; bUI.style.pointerEvents = 'auto'; 
                pUI.style.display = 'none'; jBtn.style.display = 'none'; 
                document.getElementById('builder-tools').style.display = 'flex';
                
                player.visible = false; 
                
                controls.enabled = true;
                controls.target.set(0,0,0); // Resetear centro de √≥rbita

                if(buildType!=='ramp') rollOverMesh.visible = true;
                camera.position.set(500,600,800); camera.lookAt(0,0,0);
            }
        }

        function setupMobileControls() {
            const setInput = (k, v) => { moveInput[k] = v; };
            ['up','down','left','right'].forEach(k => {
                const el = document.getElementById('dpad-'+k);
                const start = (e) => { e.preventDefault(); setInput(k,true); el.style.background='rgba(0,255,255,0.5)'; };
                const end = (e) => { e.preventDefault(); setInput(k,false); el.style.background='rgba(255,255,255,0.5)'; };
                el.addEventListener('touchstart', start, {passive:false}); el.addEventListener('touchend', end);
                el.addEventListener('mousedown', start); el.addEventListener('mouseup', end);
            });
            const j = document.getElementById('btn-jump');
            j.addEventListener('touchstart', (e)=>{ e.preventDefault(); moveInput.jump=true; }, {passive:false});
            j.addEventListener('touchend', (e)=>{ e.preventDefault(); moveInput.jump=false; });
            j.addEventListener('mousedown', (e)=>{ e.preventDefault(); moveInput.jump=true; });
            j.addEventListener('mouseup', (e)=>{ e.preventDefault(); moveInput.jump=false; });
        }

        function onResize() { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        
        function animate() { 
            requestAnimationFrame(animate); 
            const delta = clock.getDelta(); 
            update(delta); 
            // Solo actualizamos OrbitControls si NO estamos jugando
            if(!isPlayingMode) controls.update(); 
            renderer.render(scene, camera); 
        }

        function init() {
            scene = new THREE.Scene(); scene.background = new THREE.Color(0xf0f0f0); scene.fog = new THREE.FogExp2(0xf0f0f0, 0.0002);
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 5000); camera.position.set(500, 600, 800); camera.lookAt(0,0,0);
            scene.add(new THREE.AmbientLight(0xCCCCCC, 2)); const dir = new THREE.DirectionalLight(0xffffff, 2); dir.position.set(1, 2, 1); scene.add(dir);

            cubeGeo = new THREE.BoxGeometry(50, 50, 50);
            const shape = new THREE.Shape(); shape.moveTo(0,0); shape.lineTo(100,0); shape.lineTo(100,100); shape.lineTo(0,0);
            rampGeo = new THREE.ExtrudeGeometry(shape, { depth: 50, bevelEnabled: false }); rampGeo.translate(-50, -50, -25);

            const rollMat = new THREE.MeshBasicMaterial({ color: 0xff0000, opacity: 0.5, transparent: true });
            rollOverMesh = new THREE.Mesh(cubeGeo, rollMat); scene.add(rollOverMesh);
            rampGuideMesh = new THREE.Mesh(rampGeo, rollMat); rampGuideMesh.rotation.y = -Math.PI / 2; rampGuideMesh.visible = false; scene.add(rampGuideMesh);

            gridHelper = new THREE.GridHelper(CONF.gridSize, CONF.gridSize / CONF.cellSize); scene.add(gridHelper);
            const planeGeo = new THREE.PlaneGeometry(CONF.gridSize, CONF.gridSize); planeGeo.rotateX(-Math.PI / 2);
            plane = new THREE.Mesh(planeGeo, new THREE.MeshBasicMaterial({ visible: false })); scene.add(plane); objects.push(plane);

            createPlayer();
            renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setPixelRatio(window.devicePixelRatio); renderer.setSize(window.innerWidth, window.innerHeight); document.body.appendChild(renderer.domElement);
            controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping = true;

            document.addEventListener('pointermove', onPointerMove); document.addEventListener('pointerdown', onPointerDown);
            document.addEventListener('keydown', onKeyDown); document.addEventListener('keyup', onKeyUp);
            window.addEventListener('resize', onResize);
            setupUI(); setupMobileControls();
        }

        try { init(); animate(); } catch (e) { document.getElementById('error-console').style.display = 'block'; document.getElementById('error-console').innerText = "CRASH: " + e.message; }

    </script>
</body>
</html>
